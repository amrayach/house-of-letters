<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Building Preview</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #coordinates-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            font-family: monospace;
            font-size: 14px;
            border-radius: 5px;
            z-index: 100;
        }
        #coordinates-panel div {
            margin: 3px 0;
        }
    </style>
</head>
<body>
    <div id="coordinates-panel">
        <div>X: <span id="coord-x">0.00</span></div>
        <div>Y: <span id="coord-y">0.00</span></div>
        <div>Z: <span id="coord-z">0.00</span></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r98/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.98.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xaaaaaa);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(-100.93, 200.32, 66.46);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.screenSpacePanning = false;
        controls.maxPolarAngle = Math.PI / 2;

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040); // soft white light
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);
        
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight2.position.set(-1, 0.5, -1).normalize();
        scene.add(directionalLight2);

        // Load the building model
        const loader = new THREE.FileLoader();
        const jsonLoader = new THREE.JSONLoader();
        let buildingCenter = new THREE.Vector3();
        
        loader.load('building.js', function (text) {
            const json = JSON.parse(text);
            const result = jsonLoader.parse(json);
            
            const geometry = result.geometry;
            const materials = result.materials;
            
            // Ensure materials are double sided just in case
            materials.forEach(mat => {
                mat.side = THREE.DoubleSide;
            });

            const mesh = new THREE.Mesh(geometry, materials);
            scene.add(mesh);
            
            // Center the model
            geometry.computeBoundingBox();
            geometry.boundingBox.getCenter(buildingCenter);
            mesh.position.sub(buildingCenter); // Center mesh at 0,0,0

            // Adjust camera to fit object
            const size = new THREE.Vector3();
            geometry.boundingBox.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 * Math.tan(fov * 2));
            cameraZ *= 1.5; // Zoom out a bit
            
            camera.position.set(cameraZ, cameraZ, cameraZ);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();

            // Load the roof after building is loaded
            loader.load('building-roof.js', function (roofText) {
                const roofJson = JSON.parse(roofText);
                const roofResult = jsonLoader.parse(roofJson);
                
                const roofGeometry = roofResult.geometry;
                const roofMaterials = roofResult.materials;
                
                // Ensure materials are double sided
                roofMaterials.forEach(mat => {
                    mat.side = THREE.DoubleSide;
                });

                const roofMesh = new THREE.Mesh(roofGeometry, roofMaterials);
                // Position roof relative to building (using same center offset)
                roofMesh.position.sub(buildingCenter);
                scene.add(roofMesh);

            }, undefined, function (error) {
                console.error('Error loading roof:', error);
            });

            // Load the terrain
            loader.load('terrain.js', function (terrainText) {
                const terrainJson = JSON.parse(terrainText);
                const textureLoader = new THREE.TextureLoader();
                
                // Load the terrain texture
                textureLoader.load('panchromatic.jpg', function (texture) {
                    const terrainResult = jsonLoader.parse(terrainJson);
                    
                    const terrainGeometry = terrainResult.geometry;
                    
                    // Create material with the texture
                    const terrainMaterial = new THREE.MeshBasicMaterial({
                        map: texture,
                        side: THREE.DoubleSide
                    });

                    const terrainMesh = new THREE.Mesh(terrainGeometry, terrainMaterial);
                    // Position terrain relative to building (using same center offset)
                    terrainMesh.position.sub(buildingCenter);
                    scene.add(terrainMesh);

                }, undefined, function (error) {
                    console.error('Error loading terrain texture:', error);
                });

            }, undefined, function (error) {
                console.error('Error loading terrain:', error);
            });

            // Load the white building
            loader.load('whiteBuilding.js', function (whiteBuildingText) {
                const whiteBuildingJson = JSON.parse(whiteBuildingText);
                const whiteBuildingResult = jsonLoader.parse(whiteBuildingJson);
                
                const whiteBuildingGeometry = whiteBuildingResult.geometry;
                const whiteBuildingMaterials = whiteBuildingResult.materials;
                
                // Ensure materials are double sided
                whiteBuildingMaterials.forEach(mat => {
                    mat.side = THREE.DoubleSide;
                });

                const whiteBuildingMesh = new THREE.Mesh(whiteBuildingGeometry, whiteBuildingMaterials);
                // Position white building relative to main building (using same center offset)
                whiteBuildingMesh.position.sub(buildingCenter);
                scene.add(whiteBuildingMesh);

            }, undefined, function (error) {
                console.error('Error loading white building:', error);
            });

            // Load the corridor
            loader.load('corridor.js', function (corridorText) {
                const corridorJson = JSON.parse(corridorText);
                const corridorResult = jsonLoader.parse(corridorJson);
                
                const corridorGeometry = corridorResult.geometry;
                
                // Create a basic material for the corridor (no materials defined in file)
                const corridorMaterial = new THREE.MeshLambertMaterial({
                    color: 0x888888,
                    side: THREE.DoubleSide
                });

                const corridorMesh = new THREE.Mesh(corridorGeometry, corridorMaterial);
                // Position corridor relative to main building (using same center offset)
                corridorMesh.position.sub(buildingCenter);
                scene.add(corridorMesh);

            }, undefined, function (error) {
                console.error('Error loading corridor:', error);
            });

            // Load the group cell
            loader.load('groupcell-d.js', function (groupcellText) {
                const groupcellJson = JSON.parse(groupcellText);
                const groupcellResult = jsonLoader.parse(groupcellJson);
                
                const groupcellGeometry = groupcellResult.geometry;
                
                // Create a basic material for the group cell (no materials defined in file)
                const groupcellMaterial = new THREE.MeshLambertMaterial({
                    color: 0x888888,
                    side: THREE.DoubleSide
                });

                const groupcellMesh = new THREE.Mesh(groupcellGeometry, groupcellMaterial);
                // Position group cell relative to main building (using same center offset)
                groupcellMesh.position.sub(buildingCenter);
                scene.add(groupcellMesh);

            }, undefined, function (error) {
                console.error('Error loading group cell:', error);
            });

        }, undefined, function (error) {
            console.error('An error happened', error);
        });

        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Coordinate display elements
        const coordX = document.getElementById('coord-x');
        const coordY = document.getElementById('coord-y');
        const coordZ = document.getElementById('coord-z');

        // Camera transition waypoints
        const cameraWaypoints = [
            new THREE.Vector3(-100.93, 200.32, 66.46),
            new THREE.Vector3(-92.40, 171.75, 60.08),
            new THREE.Vector3(-85.09, 147.25, 54.61),
            new THREE.Vector3(-141.73, 97.58, 92.82),
            new THREE.Vector3(-107.87, 64.74, 68.88),
            new THREE.Vector3(-79.09, 36.82, 48.54),
            new THREE.Vector3(-80.77, 13.86, 54.89),
            new THREE.Vector3(-70.27, 10.19, 46.09),
            new THREE.Vector3(-61.48, 7.11, 38.74),
            new THREE.Vector3(-52.80, 5.66, 30.43),
            new THREE.Vector3(-44.17, 1.28, 21.45),
            new THREE.Vector3(-41.99, 0.04, 19.38)
        ];

        // Create a smooth Catmull-Rom spline through the waypoints
        const cameraSpline = new THREE.CatmullRomCurve3(cameraWaypoints);
        cameraSpline.curveType = 'centripetal'; // Centripetal for smoothest curves, no cusps
        cameraSpline.tension = 0.2; // Lower tension = rounder, smoother curves

        // Camera transition state
        let cameraTransition = {
            active: false,
            progress: 0,
            duration: 35000, // 35 seconds for ultra-smooth, cinematic transition
            startTime: 0,
            lookAtTarget: new THREE.Vector3(0, 0, 0),
            currentLookAt: new THREE.Vector3(0, 0, 0),
            currentPosition: new THREE.Vector3(),
            velocity: new THREE.Vector3()
        };

        // Function to start camera transition
        function startCameraTransition() {
            cameraTransition.active = true;
            cameraTransition.progress = 0;
            cameraTransition.startTime = performance.now();
            // Initialize current position to first waypoint for smooth start
            cameraTransition.currentPosition.copy(cameraWaypoints[0]);
            cameraTransition.currentLookAt.copy(cameraTransition.lookAtTarget);
            cameraTransition.velocity.set(0, 0, 0);
            controls.enabled = false; // Disable orbit controls during transition
            console.log('Camera transition started. Press "S" to stop.');
        }

        // Function to stop camera transition
        function stopCameraTransition() {
            cameraTransition.active = false;
            controls.enabled = true; // Re-enable orbit controls
            console.log('Camera transition stopped.');
        }

        // Ultra smooth easing - combination for butter-smooth motion with very gentle start/end
        function ultraSmoothEase(t) {
            // Custom blend of sine and polynomial for cinema-quality smoothness
            const sine = Math.sin(t * Math.PI - Math.PI / 2) * 0.5 + 0.5;
            const poly = t * t * t * (t * (t * 6 - 15) + 10);
            // Blend them for extra smoothness
            return sine * 0.3 + poly * 0.7;
        }

        // Linear interpolation helper (for older Three.js compatibility)
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        // Damped spring interpolation for extra smoothness
        function damp(current, target, smoothing, dt) {
            return lerp(current, target, 1 - Math.exp(-smoothing * dt));
        }

        // Damped spring for Vector3
        function dampVector3(current, target, smoothing, dt) {
            current.x = damp(current.x, target.x, smoothing, dt);
            current.y = damp(current.y, target.y, smoothing, dt);
            current.z = damp(current.z, target.z, smoothing, dt);
        }

        let lastTime = performance.now();

        // Update camera position along the spline with damping
        function updateCameraTransition() {
            if (!cameraTransition.active) return;

            const currentTime = performance.now();
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.05); // Cap delta for consistency
            lastTime = currentTime;

            const elapsed = currentTime - cameraTransition.startTime;
            let rawProgress = elapsed / cameraTransition.duration;

            if (rawProgress >= 1) {
                rawProgress = 1;
                cameraTransition.active = false;
                controls.enabled = true;
                console.log('Camera transition completed.');
            }

            // Apply ultra-smooth easing
            const easedProgress = ultraSmoothEase(rawProgress);

            // Get target position on spline
            const targetPosition = cameraSpline.getPointAt(easedProgress);

            // Apply heavy damped interpolation for buttery smooth movement
            const smoothingFactor = 1.5; // Lower = smoother, more cinematic lag
            dampVector3(cameraTransition.currentPosition, targetPosition, smoothingFactor, deltaTime);

            camera.position.copy(cameraTransition.currentPosition);

            // Smooth look-at interpolation
            dampVector3(cameraTransition.currentLookAt, cameraTransition.lookAtTarget, smoothingFactor, deltaTime);
            camera.lookAt(cameraTransition.currentLookAt);

            cameraTransition.progress = rawProgress;
        }

        // Keyboard controls
        document.addEventListener('keydown', function(event) {
            if (event.key === 'p' || event.key === 'P') {
                if (!cameraTransition.active) {
                    startCameraTransition();
                }
            } else if (event.key === 's' || event.key === 'S') {
                if (cameraTransition.active) {
                    stopCameraTransition();
                }
            } else if (event.key === 'r' || event.key === 'R') {
                // Reset camera to start position
                camera.position.copy(cameraWaypoints[0]);
                camera.lookAt(cameraTransition.lookAtTarget);
                controls.target.copy(cameraTransition.lookAtTarget);
                controls.update();
            }
        });

        console.log('Camera controls: P = Play transition, S = Stop, R = Reset to start');

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update camera transition if active
            updateCameraTransition();
            
            if (!cameraTransition.active) {
                controls.update();
            }
            
            // Update coordinates panel
            coordX.textContent = camera.position.x.toFixed(2);
            coordY.textContent = camera.position.y.toFixed(2);
            coordZ.textContent = camera.position.z.toFixed(2);
            
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
